import json
from typing import List, Tuple, Union

from mininet_gui_backend.schema import Host, Switch, Controller, Nat, Router


SCRIPT_TEMPLATE = """
\"\"\"
Script generated by Mininet-GUI (https://github.com/latarc/mininet-gui)
\"\"\"
from mininet.net import Mininet
from mininet.node import Controller, RemoteController, OVSKernelSwitch, OVSSwitch, OVSBridge, Host, Node, Ryu, NOX, UserSwitch
from mininet.link import TCLink
from mininet.cli import CLI
from mininet.log import setLogLevel

setLogLevel("info")

net = Mininet(controller=Controller, switch=OVSKernelSwitch, host=Host, link=TCLink)

{router_class}

# Controllers
{controllers}

# Switches
{switches}

# Hosts
{hosts}

# Routers
{routers}

# NATs
{nats}

# Links
{links}

net.build()

{controller_start}

{switch_start}

print("\\nNetwork topology created successfully!\\n")

CLI(net)  # Start Mininet CLI

net.stop()
"""


def export_net_to_script(
    switches: List[Switch], 
    hosts: List[Host], 
    controllers: List[Controller],
    nats: List[Nat],
    routers: List[Router],
    links: List[Tuple[str, str]]
) -> str:
    template = str(SCRIPT_TEMPLATE)

    controllers_str = "\n".join([
        c.format_controller() for c in controllers.values()
    ])

    switches_str = "\n".join([
        s.format_switch() for s in switches.values()
    ])

    hosts_str = "\n".join([
        f'{h.name} = net.addHost("{h.name}", ip="{h.ip}", mac="{h.mac}")' for h in hosts.values()
    ])

    routers_str = "\n".join([
        r.format_router()
        for r in routers.values()
    ])

    nats_str = "\n".join([
        nat.format_nat()
        for nat in nats.values()
    ])

    links_str = "\n".join([
        f'net.addLink({link_list[0]}, {link_list[1]})'
        for link_list in (list(link) for link in links.keys())
    ])

    controller_start_str = "\n".join([
        f"{c.name}.start()" for c in controllers.values()
    ])

    switch_start_str = "\n".join([
        f'{s.name}.start([{s.controller}])' if s.controller else f'{s.name}.start([])'
        for s in switches.values()
    ])

    router_class_str = ""
    if len(routers) > 0:
        router_class_str = """
class LinuxRouter(Node):
    def config(self, **params):
        super().config(**params)
        self.cmd('sysctl -w net.ipv4.ip_forward=1')
    def terminate(self):
        self.cmd('sysctl -w net.ipv4.ip_forward=0')
        super().terminate()
"""

    return template.format(
        router_class=router_class_str,
        controllers=controllers_str,
        switches=switches_str,
        hosts=hosts_str,
        routers=routers_str,
        nats=nats_str,
        links=links_str,
        controller_start=controller_start_str,
        switch_start=switch_start_str
    )


# def import_script(script):
#     for line in script.splitlines():
#         eval(line)


# json schema
def export_net_to_json(
    switches: List[Switch], 
    hosts: List[Host], 
    controllers: List[Controller],
    nats: List[Nat],
    routers: List[Router],
    links: List[Tuple[str, str]]
) -> str:
    net_data = {
        "switches": [switch.model_dump() for switch in switches.values()],
        "hosts": [host.model_dump() for host in hosts.values()],
        "routers": [router.model_dump() for router in routers.values()],
        "controllers": [controller.model_dump() for controller in controllers.values()],
        "nats": [nat.model_dump() for nat in nats.values()],
        "links": [list(link) for link in links]
    }

    return json.dumps(net_data, indent=4)
