import json
from datetime import datetime, timezone
from typing import List, Tuple, Union

from mininet.node import Node

from mininet_gui_backend.schema import Host, Switch, Controller, Nat, Router
from mininet_gui_backend.utils import parse_ip_addrs


SCRIPT_TEMPLATE = """
\"\"\"
Script generated by Mininet-GUI (https://github.com/latarc/mininet-gui)
\"\"\"
from mininet.net import Mininet
from mininet.node import Controller, RemoteController, OVSKernelSwitch, OVSSwitch, OVSBridge, Host, Node, NOX, UserSwitch
from mininet.link import TCLink
from mininet.cli import CLI
from mininet.log import setLogLevel
from mininet.util import errRun
from mininet.moduledeps import pathCheck

setLogLevel("info")

net = Mininet(controller=Controller, switch=OVSKernelSwitch, host=Host, link=TCLink)

{ryu_class}
{router_class}

# Controllers
{controllers}

# Switches
{switches}

# Hosts
{hosts}

# Routers
{routers}

# NATs
{nats}

# Links
{links}

net.build()

{openflow_versions}

{controller_start}

{switch_start}

print("\\nNetwork topology created successfully!\\n")

CLI(net)  # Start Mininet CLI

net.stop()
"""


def export_net_to_script(
    switches: List[Switch], 
    hosts: List[Host], 
    controllers: List[Controller],
    nats: List[Nat],
    routers: List[Router],
    links: List[Tuple[str, str]]
) -> str:
    template = str(SCRIPT_TEMPLATE)

    controllers_str = "\n".join([
        c.format_controller() for c in controllers.values()
    ])

    ryu_class_str = ""
    if any((c.controller_type or "").lower() == "ryu" for c in controllers.values()):
        ryu_class_str = """
class Ryu(Node):
    \"\"\"Ryu controller node.\"\"\"

    def __init__(self, name, inNamespace=False, ip="127.0.0.1", port=6653, ryu_app="simple_switch_13", **params):
        self.ip = ip
        self.port = int(port)
        self.ryu_app = ryu_app
        self.ryu_pid = None
        Node.__init__(self, name, inNamespace=inNamespace, ip=ip, **params)
        self.checkListening()

    def checkListening(self):
        out, _err, returnCode = errRun("which telnet")
        if "telnet" not in out or returnCode != 0:
            raise Exception("Error running telnet to check for listening controllers; please check that it is installed.")
        listening = self.cmd("echo A | telnet -e A %s %d" % (self.ip, self.port))
        if "Connected" in listening:
            servers = self.cmd("netstat -natp").split("\\n")
            pstr = ":%d " % self.port
            clist = servers[0:1] + [s for s in servers if pstr in s]
            raise Exception("Please shut down the controller which is running on port %d:\\n" % self.port + "\\n".join(clist))

    def start(self):
        pathCheck("ryu")
        cout = "/tmp/" + self.name + ".log"
        cmd = "ryu run --ofp-tcp-listen-port %d ryu.app.%s" % (self.port, self.ryu_app)
        pid = self.cmd(cmd + " 1>" + cout + " 2>" + cout + " & echo $!")
        try:
            self.ryu_pid = int(pid.strip())
        except Exception:
            self.ryu_pid = None
        self.execed = False

    def stop(self, *args, **kwargs):
        if self.ryu_pid:
            self.cmd("kill %s" % self.ryu_pid)
        else:
            self.cmd("kill %ryu")
        super(Ryu, self).stop(*args, **kwargs)
"""

    switches_str = "\n".join([
        s.format_switch() for s in switches.values()
    ])

    hosts_str = "\n".join([
        f'{h.name} = net.addHost("{h.name}", ip="{h.ip}", mac="{h.mac}")' for h in hosts.values()
    ])

    routers_str = "\n".join([
        r.format_router()
        for r in routers.values()
    ])

    nats_str = "\n".join([
        nat.format_nat()
        for nat in nats.values()
    ])

    links_str = "\n".join([
        f'net.addLink({link_list[0]}, {link_list[1]})'
        for link_list in (list(link) for link in links.keys())
    ])

    controller_start_str = "\n".join([
        f"{c.name}.start()" for c in controllers.values()
    ])

    switch_start_str = "\n".join([
        f'{s.name}.start([{s.controller}])' if s.controller else f'{s.name}.start([])'
        for s in switches.values()
    ])

    openflow_versions_str = "\n".join([
        f'errRun("ovs-vsctl --if-exists set bridge {s.name} protocols={s.of_version}")'
        for s in switches.values()
        if getattr(s, "of_version", None)
    ])

    router_class_str = ""
    if len(routers) > 0:
        router_class_str = """
class LinuxRouter(Node):
    def config(self, **params):
        super().config(**params)
        self.cmd('sysctl -w net.ipv4.ip_forward=1')
    def terminate(self):
        self.cmd('sysctl -w net.ipv4.ip_forward=0')
        super().terminate()
"""

    return template.format(
        ryu_class=ryu_class_str,
        router_class=router_class_str,
        controllers=controllers_str,
        switches=switches_str,
        hosts=hosts_str,
        routers=routers_str,
        nats=nats_str,
        links=links_str,
        openflow_versions=openflow_versions_str,
        controller_start=controller_start_str,
        switch_start=switch_start_str
    )


# def import_script(script):
#     for line in script.splitlines():
#         eval(line)


# json schema
def export_net_to_json(
    switches: List[Switch], 
    hosts: List[Host], 
    controllers: List[Controller],
    nats: List[Nat],
    routers: List[Router],
    links: List[Tuple[str, str]]
) -> str:
    net_data = {
        "switches": [switch.model_dump() for switch in switches.values()],
        "hosts": [host.model_dump() for host in hosts.values()],
        "routers": [router.model_dump() for router in routers.values()],
        "controllers": [controller.model_dump() for controller in controllers.values()],
        "nats": [nat.model_dump() for nat in nats.values()],
        "links": [list(link) for link in links]
    }

    return json.dumps(net_data, indent=4)


def build_addressing_plan(net: "Mininet") -> dict:
    nodes = []
    for node_id, node in net.nameToNode.items():
        node_type = getattr(node, "type", None)
        if not node_type:
            continue
        intfs = []
        for intf in node.intfList():
            if not intf.name or intf.name in ("lo", "lo0"):
                continue
            ipv4_out, _, _ = node.pexec(f"ip -o -4 addr show {intf.name}")
            ipv6_out, _, _ = node.pexec(f"ip -o -6 addr show {intf.name}")
            ipv4 = parse_ip_addrs(ipv4_out)
            ipv6 = parse_ip_addrs(ipv6_out)
            mac = None
            try:
                mac = intf.MAC()
            except Exception:
                pass
            intfs.append(
                {
                    "name": intf.name,
                    "mac": mac,
                    "ipv4": ipv4,
                    "ipv6": ipv6,
                }
            )
        nodes.append(
            {
                "id": node_id,
                "type": node_type,
                "intfs": intfs,
            }
        )
    return {
        "generated_at": datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
        "nodes": nodes,
    }
